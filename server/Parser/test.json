{
    "article_name": "Telegram Desktop и Compose Multiplatform",
    "article_url": "https://habr.com/ru/articles/803987/",
    "article_context": [
        "<url img>https://habrastorage.org/r/w1560/getpro/habr/upload_files/334/6cc/1a5/3346cc1a529358ae66dd2f635343c3e8.png</url img>",
        "<title img>Пример того, как будет выглядеть чат с изображениями.</title img>",
        "<p>Всем привет! В своей прошлой статье я рассказывал как можно запустить Telegram клиент в качестве backend‑сервиса. В описываемой там библиотеке с тех пор были внесены некоторые оптимизации, и в целом, я остался доволен возможностями, которые получил. После чего возникло желание добавить визуальную часть к имеющемуся бэкенду и заодно изучить что‑то новое для себя. Выбор пал на фреймворк Compose Multiplatform. Давайте сделаем десктопную версию Telegram!</p>",
        "<h>С чего начать?</h>",
        "<p>Compose Multiplatform — это декларативный фреймворк для построения интерфейсов под различные платформы с использованием Kotlin и Jetpack Compose. И так как это был мой первый опыт работы с Jetpack Compose, то поэтому в начале я прочитал некоторые статьи и прошел несколько лабораторок на портале разработчиков для android. После можно посмотреть tutorials непосредственно в репозитории Compose Multiplatform от JetBrains.</p>",
        "<h>Создаем проект</h>",
        "<p>Создать проект можно из IntelliJ IDEA(достаточно версии community) выбрав шаблон Compose for Desktop или через wizard. В итоге формируется Gradle проект, где уже подключены необходимые плагины и зависимости для фреймворка, а если нам нужно что‑то дополнительно, то это можно добавить в виде зависимости. В нашем случае помимо UI‑части будет еще и бэкенд, то есть при запуске нативного приложения должен будет запуститься еще java‑процесс параллельно. Получается, что при компиляции нативного приложения Compose‑плагин должен знать какие сторонние ресурсы мы используем и учесть это, а у нас должна быть возможность обращаться к ним из нашего кода. Указать каталог с ресурсами можно через установку appResourcesRootDir, давайте назовем его resources и расположим в корне проекта:</p>",
        "<p>Теперь мы можем с помощью свойства compose.application.resources.dir обращаться к подключаемым ресурсам, я для этого сделал вспомогательный класс:</p>",
        "<p>Давайте посмотрим как выглядит итоговая структура каталога ресурсов, чтобы обратить внимание на еще одну важную вещь:</p>",
        "<p>У Compose-плагина есть правило по работе с подкаталогами ресурсов. Каталог common содержит файлы, которые будут включены в сборку для любой платформы. Для включения файлов под конкретную ОС и архитектуру существуют правила именования - <resource_dir>/<os_name> или <resource_dir>/<os_name>-<arch_name>(возможные ОС - windows, macos, linux; архитектуры - x64, arm64). При сборке приложения плагин самостоятельно сможет взять необходимые файлы под нужную архитектуру. В нашем случае в каталог common отправится jar бэкенда, а в специфичных каталогах платформ будут лежать скомпилированные нативные библиотеки TDLib для бэкенда(особенности работы с данной библиотекой можно посмотреть в моей статье).</p>",
        "<h>Начнем реализацию</h>",
        "<p>При старте приложения мы покажем первое окно в котором будет отображаться статус запуска, а также запустим бэкенд параллельно.</p>",
        "<p>На следующем шаге нам нужно проверить авторизован ли клиент, чтобы продолжить работу.</p>",
        "<p>Если необходима авторизация, то появится простая форма ввода кода, который придет в официальный клиент.</p>",
        "<url img>https://habrastorage.org/r/w1560/getpro/habr/upload_files/808/28c/165/80828c165bf3d4d1671267c09d318abc.png</url img>",
        "<title img>None</title img>",
        "<p>Если активирован второй фактор верификации, то его тоже придется ввести.</p>",
        "<url img>https://habrastorage.org/r/w1560/getpro/habr/upload_files/332/033/0b7/3320330b7849013e0835686875b00488.png</url img>",
        "<title img>None</title img>",
        "<p>После авторизации и загрузки списка чатов(кэширование иконок и прочей информации) можно отобразить основную сцену клиента. Я сделал максимально простой вариант — это список чатов с их фильтрацией слева, а также справа место под окно чата, который мы выбрали. Чтобы отображать список чатов корректно, недостаточно их просто загрузить — нужно выполнить подписку на обновления, которые в этом списке могут происходить, а именно:</p>",
        "<p>Может появиться новый чат</p>",
        "<p>Чат в списке может быть удален</p>",
        "<p>В чате может измениться иконка, заголовок</p>",
        "<p>Меняется последнее сообщение, которые мы тоже отображаем</p>",
        "<p>Должен появляться счетчик непрочитанных сообщений, он может менять значение</p>",
        "<p>Меняется позиция чата в списке, чаты с новыми сообщениями поднимаются в списке выше.</p>",
        "<p>Чтобы разобраться, что это за обновления и как их получать давайте немного посмотрим в бэкенд. В данном случае это обычный Spring Boot проект. В нем я создал пакет tdlib, в котором зарегистрировал компоненты самых необходимых на данном этапе оповещений от TDLib, вот его состав:</p>",
        "<p>Для примера, давайте посмотрим на событие обновления иконки чата: </p>",
        "<p>В данном случае это обычный Spring компонент, в котором к нам прилетает нотификация, что иконка обновилась. Дальше мы вольны делать с этим что угодно. Я просто кэширую объект и перекладываю обновление в очередь. Аналогично можно работать с любыми другими обновлениями в клиенте. В итоге я сделал сервис, который может собирать и передавать обновления для списка чатов.</p>",
        "<p>Вернемся к UI. Теперь мы можем отобразить список карточек чатов:</p>",
        "<p>По данному списку возможен скролл, фильтрация, переключение на непрочитанные чаты, а также можно удалить чат или отметить прочитанным.</p>",
        "<p></p>",
        "<p>По такой же логике можно работать и с окном чата. Когда мы его открываем, то подгружаем из истории какой‑то первоначальный список сообщений, а при скролле выполняем загрузку уже динамически. Плюс нам нужно следить за обновлениями в открытом чате:</p>",
        "<p>Изменение названия чата</p>",
        "<p>Если это группа или канал, то следим за изменением счетчика участников.</p>",
        "<p>Если получаем новое сообщение, то дописываем в список.</p>",
        "<p>В отображенных сообщениях может быть изменен контент, поэтому тоже следим.</p>",
        "<p>Если сообщение удаляется, то нам его тоже нужно удалить.</p>",
        "<p>Выглядеть это будет так.</p>",
        "<url img>https://habrastorage.org/r/w1560/getpro/habr/upload_files/f3f/2f6/75a/f3f2f675a14baaa818c472c5cc7083bc.png</url img>",
        "<title img>None</title img>",
        "<p>Конечно, это очень базовая функциональность. Пока корректно отображаются только текстовые сообщения и фото, а в Telegram много различных типов сообщений(видео, анимации, документы, опросы, стикеры, эмодзи и т. д.). Также пока не выделяются текстовые блоки и ссылки, но я хочу скоро это добавить вместе с возможностью отправки сообщений. Чаты‑форумы пока тоже не поддерживаются, там все сообщения отображаются в корневом чате(в TDLib эта функциональность не до конца перенесена еще, думаю подождать).</p>",
        "<h>Соберем проект</h>",
        "<p>Compose-плагин позволяет запускать приложение для jvm-платформы в виде java-процесса(run), собрать готовый к запуску jar для текущей платформы(packageUberJarForCurrentOS), скомпилировать нативное приложение(createDistributable, packageDistributionForCurrentOS), выполнить запуск нативного приложения из плагина(runDistributable). Вот полный список задач плагина:</p>",
        "<p></p>",
        "<p>Давайте теперь посмотрим куда же отправляются в итоге подключаемые ресурсы на примере нативного приложения под MacOS. Если мы попросим показать содержимое .app пакета, то увидим(вывод сократил, конечно):</p>",
        "<p>А вот и они — наш бэкенд, нативная библиотека TDLib для него и gif c loader'ом загрузки контента. При запуске приложения оно к ним успешно обращается и все работает как ожидалось.</p>",
        "<p>В репозитории проекта я описал подробную инструкцию, что нужно подготовить для приложения и добавил скрипт сборки. Нативное приложение получилось протестировать на MacOS(x64 + M) и Windows(x64). Поэтому если кому‑то интересно, то обязательно заходите:)</p>",
        "<h>Итоги</h>",
        "<p>Мы рассмотрели как можем создавать и собирать desktop приложение используя фреймворк Compose Multiplatform. Получился Telegram клиент с очень базовой функциональностью, но это может выступить скелетом для будущих доработок, а практическая реализация позволяет погрузиться в изучение Telegram API более детально. От Compose Multiplatform у меня остались приятные впечатления, постараюсь продолжить изучать возможности фреймворка. Надеюсь, что вам было интересно!</p>",
        "<p>Полезные ссылки:</p>",
        "<p>telegram‑desktop‑compose‑multiplatform — репозиторий проекта данной статьи</p>",
        "<p>spring‑boot‑starter‑telegram — репозиторий фреймворка, который используется в бэкенде этого проекта</p>",
        "<p>compose‑multiplatform — страница Compose Multiplatform</p>",
        "<p>Jetpack Compose — страница для изучения Jetpack Compose</p>",
        "<p>Tutorials — туториалы по Compose Multiplatform от JetBrains</p>",
        "<p></p>"
    ]
}